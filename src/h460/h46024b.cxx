//
// H46024B.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "h46024b.h"
#endif

#include <ptlib.h>
#include <h460/h46024b.h>

#define new PNEW


#if ! H323_DISABLE_H46024B

//
// AlternateAddress
//

H46024B_AlternateAddress::H46024B_AlternateAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_sessionID.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H46024B_AlternateAddress::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "sessionID = " << setprecision(indent) << m_sessionID << '\n';
  if (HasOptionalField(e_rtpAddress))
    strm << setw(indent+13) << "rtpAddress = " << setprecision(indent) << m_rtpAddress << '\n';
  if (HasOptionalField(e_rtcpAddress))
    strm << setw(indent+14) << "rtcpAddress = " << setprecision(indent) << m_rtcpAddress << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H46024B_AlternateAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H46024B_AlternateAddress), PInvalidCast);
#endif
  const H46024B_AlternateAddress & other = (const H46024B_AlternateAddress &)obj;

  Comparison result;

  if ((result = m_sessionID.Compare(other.m_sessionID)) != EqualTo)
    return result;
  if ((result = m_rtpAddress.Compare(other.m_rtpAddress)) != EqualTo)
    return result;
  if ((result = m_rtcpAddress.Compare(other.m_rtcpAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H46024B_AlternateAddress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sessionID.GetObjectLength();
  if (HasOptionalField(e_rtpAddress))
    length += m_rtpAddress.GetObjectLength();
  if (HasOptionalField(e_rtcpAddress))
    length += m_rtcpAddress.GetObjectLength();
  return length;
}


PBoolean H46024B_AlternateAddress::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sessionID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rtpAddress) && !m_rtpAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rtcpAddress) && !m_rtcpAddress.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H46024B_AlternateAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sessionID.Encode(strm);
  if (HasOptionalField(e_rtpAddress))
    m_rtpAddress.Encode(strm);
  if (HasOptionalField(e_rtcpAddress))
    m_rtcpAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H46024B_AlternateAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H46024B_AlternateAddress::Class()), PInvalidCast);
#endif
  return new H46024B_AlternateAddress(*this);
}


//
// ArrayOf_AlternateAddress
//

H46024B_ArrayOf_AlternateAddress::H46024B_ArrayOf_AlternateAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H46024B_ArrayOf_AlternateAddress::CreateObject() const
{
  return new H46024B_AlternateAddress;
}


H46024B_AlternateAddress & H46024B_ArrayOf_AlternateAddress::operator[](PINDEX i) const
{
  return (H46024B_AlternateAddress &)array[i];
}


PObject * H46024B_ArrayOf_AlternateAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H46024B_ArrayOf_AlternateAddress::Class()), PInvalidCast);
#endif
  return new H46024B_ArrayOf_AlternateAddress(*this);
}


//
// AlternateAddresses
//

H46024B_AlternateAddresses::H46024B_AlternateAddresses(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H46024B_AlternateAddresses::PrintOn(ostream & strm) const
{
  int indent = (int)strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "addresses = " << setprecision(indent) << m_addresses << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H46024B_AlternateAddresses::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H46024B_AlternateAddresses), PInvalidCast);
#endif
  const H46024B_AlternateAddresses & other = (const H46024B_AlternateAddresses &)obj;

  Comparison result;

  if ((result = m_addresses.Compare(other.m_addresses)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H46024B_AlternateAddresses::GetDataLength() const
{
  PINDEX length = 0;
  length += m_addresses.GetObjectLength();
  return length;
}


PBoolean H46024B_AlternateAddresses::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_addresses.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H46024B_AlternateAddresses::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_addresses.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H46024B_AlternateAddresses::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H46024B_AlternateAddresses::Class()), PInvalidCast);
#endif
  return new H46024B_AlternateAddresses(*this);
}


#endif // if ! H323_DISABLE_H46024B


// End of H46024B.cxx
